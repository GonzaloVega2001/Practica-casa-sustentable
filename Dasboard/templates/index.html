{% load static %}
<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Sistema de Monitoreo - Termocuplas</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  </head>

  <!-- ✅ Body corregido -->
  <body class="bg-image">
    <div>
      <!-- Sidebar -->
      <div class="sidebar bg-dark text-white" id="sidebar">
        <div class="sidebar-header d-flex align-items-center justify-content-between p-3">
          <div class="logo-group d-flex align-items-center">
           
          </div>
          <button id="sidebarToggleBtn" class="btn btn-sm btn-outline-light" aria-label="Alternar barra lateral">
            <i class="bi bi-chevron-left"></i>
          </button>
        </div>
          <!-- Labtes small logo placed above the main navigation (visible in expanded, small in collapsed) -->
          <div class="labtes-top d-flex justify-content-center align-items-center mb-2">
            <img src="{% static 'img/logolaptes.png' %}" alt="labtes" class="labtes-logo">
          </div>
        <div class="sidebar-menu">
          <ul class="nav flex-column">
            <li class="nav-item">
              <a href="#" class="nav-link text-white active" data-view="general">
                <span class="nav-icon"><i class="bi bi-speedometer2"></i></span>
                <span class="nav-label">Dashboard General</span>
              </a>
            </li>

            <li class="nav-item">
              <a href="#" class="nav-link text-white" data-bs-toggle="collapse" data-bs-target="#sensoresSubmenu" aria-expanded="false" aria-controls="sensoresSubmenu">
                <span class="nav-icon"><i class="bi bi-thermometer-half"></i></span>
                <span class="nav-label">Sensores</span>
                <span class="nav-caret ms-auto"><i class="bi bi-chevron-down"></i></span>
              </a>
              <div class="collapse" id="sensoresSubmenu">
                <ul class="nav flex-column ms-3">
                  <li class="nav-item">
                    <a href="#" class="nav-link text-white" data-view="sensor" data-sensor="all">
                      <span class="nav-icon"><i class="bi bi-list"></i></span>
                      <span class="nav-label">Todos los Sensores</span>
                    </a>
                  </li>
                  {% for sensor in sensor_keys %}
                  <li class="nav-item">
                    <a href="#" class="nav-link text-white" data-view="sensor" data-sensor="{{ sensor }}">
                      <span class="nav-icon"><i class="bi bi-thermometer-half"></i></span>
                      <span class="nav-label">Sensor {{ sensor }}</span>
                    </a>
                  </li>
                  {% empty %}
                  <li class="nav-item"><span class="nav-link text-white small">No hay sensores</span></li>
                  {% endfor %}
                </ul>
              </div>
            </li>
          </ul>
          <div class="logo-main-wrap d-flex align-items-center">
              <img src="{% static 'img/logoupla.png' %}" alt="Logo UPLA" class="logo-main">
            </div>
        </div>
      </div>

      <!-- ✅ Main Content -->
      <div class="main-content">
        <div class="container-fluid p-4">
          <div class="dashboard-wrapper d-flex justify-content-center">
            <div class="dashboard-panel w-100">
              
              <div class="panel-title text-center py-3">
                <h2 class="m-0">Dashboard de Sensores</h2>
                <small class="text-muted">Visualización de temperaturas</small>
              </div>
              
              <div class="panel-body p-3">
                <div class="row mb-2">
                  <div class="col-12">
                    <h1 class="h5 visually-hidden" id="page-title">
                      <i class="bi bi-speedometer2"></i> Dashboard General
                    </h1>
                  </div>
                </div>
                <div id="contenedor-sensores" class="row gy-4">
                  <!-- partial HTML will be inserted here -->
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Footer -->
        <footer class="bg-dark text-light mt-auto">
            <div class="container py-3">
              <div class="d-flex align-items-center justify-content-center">
                <div>
                  Sitio LAPTES-FING desarrollado por
                    <a href="https://www.upla.cl/noticias/contactanos/" target="_blank" class="text-white fw-bold text-decoration-none ms-1">
                      Dirección General de Comunicaciones
                    </a>
                  
                </div>
              </div>
            </div>
        </footer>
      </div>
    </div>


        <!-- Styles -->
        <style>
            .bg-image {
                background-image: url("{% static 'img/background.jpg' %}");
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
                overflow: auto; /* allow page scrolling */
            }

            /* Hide native scrollbars visually while preserving scrolling (Option A)
               - Firefox: scrollbar-width
               - IE/Edge: -ms-overflow-style
               - Webkit: ::-webkit-scrollbar */
            html, body {
                scrollbar-width: none; /* Firefox */
                -ms-overflow-style: none; /* IE 10+ */
            }
      html::-webkit-scrollbar, body::-webkit-scrollbar { width: 0; height: 0; background: transparent; }

      /* Also hide internal panel scrollbar visually while keeping scroll behavior */
      .panel-body {
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE 10+ */
      }
      .panel-body::-webkit-scrollbar { width: 0; height: 0; background: transparent; }
            
            /* Sidebar layout */
            :root{ --sidebar-expanded:260px; --sidebar-collapsed:72px; --sidebar-left-offset:0px; }
            /* Sidebar as a fixed panel (no border radius) */
            .sidebar { width:var(--sidebar-expanded); position:fixed; left:var(--sidebar-left-offset); top:0; bottom:0; z-index:220; background: linear-gradient(180deg,#17191c 0%, #23272b 100%); border-radius:0; transition: width .18s ease, left .18s ease; padding:18px 12px; box-shadow: 0 12px 40px rgba(2,6,23,0.08); display:flex; flex-direction:column; align-items:stretch; overflow:visible; }
            .sidebar.collapsed { width:var(--sidebar-collapsed); }

            /* Logo group */
            /* Avatar / main logo styling: centered and moderate size */
            .logo-main { width:150px; height:150px; border-radius:6px; object-fit:contain; display:block; }
            .logo-main-wrap { display:flex;width:100%; justify-content:center; }
            /* badge (small circular) shown in expanded as decorative badge; shrinks when collapsed */
            /* Secondary badge shown to the right of avatar in expanded state */
            .logo-badge { width:150px; height:150px; border-radius:50%; border:3px solid #fff; padding:4px; background:#fff; box-shadow: 0 4px 12px rgba(0,0,0,0.18); display:flex; align-items:center; justify-content:center; object-fit:contain; }
            .logo-badge-wrap { margin-left:10px; display:flex; align-items:center; justify-content:center; }
            /* In collapsed mode hide main logo and use a smaller badge centered */
            .sidebar.collapsed .logo-main { display:none !important; }
            .sidebar.collapsed .logo-badge-wrap { display:flex !important; margin-left:0 !important; justify-content:center; }
            .sidebar.collapsed .logo-badge { width:36px !important; height:36px !important; border-width:3px !important; padding:3px !important; }

            /* Labtes logo above nav */
            .labtes-top { padding:6px 0 6px 0; display:flex; justify-content:center; }
            .labtes-logo { width:150px; height:150px; object-fit:contain; border-radius:50%; }
            .sidebar.collapsed .labtes-logo{ width:80px; height:80px; }

            .sidebar-menu { padding: 18px 6px; display:flex; flex-direction:column; align-items:center; gap:10px; }
            .nav-link { padding:0.4rem 0.6rem; border-radius:10px; margin-bottom:0; display:flex; align-items:center; gap:12px; width:100%; justify-content:flex-start; }
            .nav-link { cursor: pointer; }
            .nav-link:hover { background-color: rgba(255,255,255,0.04); }
            .nav-link.active { background-color: rgba(255,255,255,0.06); }

            .nav-icon { width:44px; height:44px; display:inline-flex; align-items:center; justify-content:center; border-radius:10px; background: rgba(255,255,255,0.03); color:#fff; }
            .nav-label { color: #e6eef3; font-size:0.98rem; }
            .nav-caret { color: #cbd5e1; }

            /* Collapsed state: hide labels, center icons */
            .sidebar.collapsed .nav-label{ display:none; }
            .sidebar.collapsed .nav-caret{ display:none; }
            .sidebar.collapsed { padding-left:12px; padding-right:12px; }
            .sidebar.collapsed .nav-link{ justify-content:center; padding-left:16px; padding-right:16px; }
            .sidebar.collapsed .nav-link .nav-icon{ width:44px; height:44px; margin:0 auto; }
            .sidebar.collapsed .sidebar-menu{ gap:14px; }

        /* When the sidebar is collapsed, show the sensores submenu as a flat vertical menu
          (not as an overlay/collapsible). Remove indentation and show only icons. */
        .sidebar.collapsed #sensoresSubmenu { display: block !important; max-height: none !important; }
        .sidebar.collapsed #sensoresSubmenu .nav { margin-left: 0 !important; padding-left: 0 !important; }
        .sidebar.collapsed #sensoresSubmenu .nav-link { justify-content:center; padding-left:0.6rem; padding-right:0.6rem; }
        .sidebar.collapsed #sensoresSubmenu .nav-link .nav-icon { margin: 0; }

            /* sidebar header and toggle styling: keep toggle visually on the edge but not overlapping content */
            .sidebar-header { position: relative; }
            #sidebarToggleBtn { position: absolute; right: -18px; top: 50%; transform: translateY(-50%); width:40px; height:40px; padding:0.15rem; display:flex; align-items:center; justify-content:center; border-radius:8px; z-index:230; box-shadow: 0 6px 18px rgba(2,6,23,0.25); }
            #sidebarToggleBtn i { font-size:1rem; }

            /* Icon sizing adjustments when collapsed to center them nicely */
            .nav-icon { width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; background: rgba(255,255,255,0.03); color:#fff; }
            .sidebar.collapsed .nav-icon{ width:44px; height:44px; border-radius:10px; }

            /* Ensure the sidebar doesn't clip the toggle button */
            .sidebar { overflow: visible; }

            /* Main content offset so it doesn't overlap fixed sidebar */
            .main-content { padding-left: calc(var(--sidebar-left-offset) + var(--sidebar-expanded) + 12px); min-height:100vh; display:flex; flex-direction:column; transition: padding-left .18s ease; }
            .sidebar.collapsed ~ .main-content, .sidebar.collapsed + .main-content { padding-left: calc(var(--sidebar-left-offset) + var(--sidebar-collapsed) + 12px); }

            /* Footer fixed full-width so background reaches the left edge and no gap appears */
            footer { position: fixed; left: 0; right: 0; bottom: 0; z-index: 90; background: #212529; }
            footer .container { padding-left: calc(var(--sidebar-left-offset) + var(--sidebar-expanded) + 12px); }
            .sidebar.collapsed ~ .main-content footer .container, .sidebar.collapsed + .main-content footer .container { padding-left: calc(var(--sidebar-left-offset) + var(--sidebar-collapsed) + 12px); }
            /* make space at the bottom of main content so footer doesn't overlap content */
            .main-content { padding-bottom: 84px; }

            /* Centrar el panel y dejar espacio en blanco a la derecha (panel fijo centrado) */
            .dashboard-wrapper { justify-content: center; }
            .dashboard-panel { width: 100%;}

            .chart-container { padding:.6rem; border-radius:.5rem; background:rgba(255,255,255,0.85); display:flex; flex-direction:column; gap:.5rem; }
            .chart-row { flex:1 1 auto; display:flex; flex-direction:column; min-height:220px; }
            .chart-row .row { flex:1 1 auto; margin:0; }
            .chart-row .col-12.col-sm-8, .chart-row .col-12.col-sm-4 { display:flex; flex-direction:column; gap:.25rem; }
          
            .chart-row canvas { width:100% !important;  display:block; flex:1 1 auto; }
            /* clases para controlar altura (copiadas de Dashboard.html) */
            /* equal heights for both charts */
            .chart-temp-canvas, .chart-hum-canvas { height: 200px !important; display:block; }
            @media (min-width: 768px) {
                .chart-temp-canvas, .chart-hum-canvas { height: 240px !important; }
            }
            @media (min-width: 1200px) {
                .chart-temp-canvas, .chart-hum-canvas { height: 260px !important; }
            }
            .combined-legend{ font-size:13px; color:#374151; }
            .legend-dot{ width:12px; height:12px; display:inline-block; border-radius:50%; margin-right:6px; vertical-align:middle; box-shadow:0 0 0 3px rgba(0,0,0,0.03) inset; }
            .legend-item{ display:inline-flex; align-items:center; gap:6px; padding:4px 8px; background: transparent; border-radius:6px; }
            /* Hacer que el contenedor de tarjetas tenga overflow y sea scrollable */
      .panel-body {
                /* limitar altura para permitir scroll interno dentro del panel */
                max-height: calc(100vh - 200px);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch; /* Scroll suave en iOS */
                padding-right: 2px; /* espacio para el scrollbar */
            }

            /* Asegurar que el contenedor donde se insertan las tarjetas use overflow en X oculto */
            #contenedor-sensores { overflow-x: hidden; }

            /* Footer logos removed - footer restored to simple centered layout */
        </style>

        <!-- Scripts -->
        <script>
            (function(){
                const cardsRow = document.getElementById('contenedor-sensores');
                // Keep references to created Chart instances so we can resize/destroy them
                window.__chartInstances = window.__chartInstances || {};
                const chartInstances = window.__chartInstances;

                function destroyAllCharts(){
                    try{
                        Object.keys(chartInstances).forEach(k=>{
                            try{ chartInstances[k].destroy(); }catch(e){}
                            try{ delete chartInstances[k]; }catch(e){}
                        });
                    }catch(e){ console.warn('Error al destruir charts', e); }
                }

                // debounced resize helper
                function debounce(fn, wait){ let t; return function(...args){ clearTimeout(t); t = setTimeout(()=>fn.apply(this,args), wait); }; }

                // on resize, ask each chart to resize
                const handleResize = debounce(()=>{
                    try{ Object.values(chartInstances).forEach(c=>{ if(c && typeof c.resize==='function') c.resize(); }); }
                    catch(e){ console.warn('Error redimensionando charts', e); }
                }, 200);

                window.addEventListener('resize', handleResize);

                // Observe the cards container to handle layout changes (e.g., devtools docked)
                if(window.ResizeObserver){
                    try{
                        const ro = new ResizeObserver(debounce(()=>{
                            try{ Object.values(chartInstances).forEach(c=>{ if(c && typeof c.resize==='function') c.resize(); }); }
                            catch(e){ console.warn('ResizeObserver error', e); }
                        }, 150));
                        ro.observe(cardsRow);
                    }catch(e){ /* ignore */ }
                }

                function setupMenu(){
                    const menuLinks = document.querySelectorAll('[data-view]');
                    menuLinks.forEach(link=>{
                        link.addEventListener('click', function(e){
                            e.preventDefault();
                            menuLinks.forEach(l=>l.classList.remove('active'));
                            this.classList.add('active');
                            const view = this.dataset.view; const sensor = this.dataset.sensor;
                            if(view==='general'){
                              // Show the tabular general dashboard partial
                              saveState({view:'general', sensor:null});
                              setLayoutForView('dashboard');
                              loadGeneralPartial();
                            } else if(view==='dashboard'){
                              saveState({view:'dashboard', sensor:null});
                              setLayoutForView('dashboard');
                              loadSensors();
                            } else if(view==='sensor') {
                                // sensor may be 'all' or a specific id
                                saveState({view:'sensor', sensor: sensor});
                                setLayoutForView('sensor');
                                if(sensor==='all') loadSensors(); else loadSensor(sensor);
                            }
                        });
                    });
                }

        // Sidebar toggle logic: collapse/expand and persist state
        (function(){
          const sidebar = document.getElementById('sidebar');
          const toggle = document.getElementById('sidebarToggleBtn');
          if(!sidebar || !toggle) return;
          // keep track of initialized bootstrap tooltip instances so we can dispose them
          const tooltipMap = new Map();
          function enableTooltips(){
            const links = sidebar.querySelectorAll('.nav-link');
            links.forEach(l=>{
              const lbl = l.querySelector('.nav-label');
              if(!lbl) return;
              // set tooltip attributes - bootstrap will take the title and suppress native tooltip
              l.setAttribute('data-bs-toggle','tooltip');
              l.setAttribute('title', lbl.textContent.trim());
              try{
                const inst = new bootstrap.Tooltip(l, { placement: 'right', container: document.body });
                tooltipMap.set(l, inst);
              }catch(e){ /* ignore if bootstrap not available */ }
            });
          }
          function disableTooltips(){
            tooltipMap.forEach((inst, el)=>{ try{ inst.dispose(); }catch(e){} });
            tooltipMap.clear();
            const links = sidebar.querySelectorAll('.nav-link');
            links.forEach(l=>{ l.removeAttribute('data-bs-toggle'); l.removeAttribute('title'); l.removeAttribute('data-bs-original-title'); });
          }
          function setCollapsed(val){
            if(val) sidebar.classList.add('collapsed'); else sidebar.classList.remove('collapsed');
            // manage tooltips: use Bootstrap tooltips when collapsed, remove when expanded
            if(val) enableTooltips(); else disableTooltips();
            // When collapsing, ensure the sensores submenu is visible as flat menu; when expanding, collapse it by default
            try{
                const sensoresSubmenuLocal = document.getElementById('sensoresSubmenu');
                const sensoresToggleLocal = document.querySelector('[data-bs-target="#sensoresSubmenu"]');
                if(sensoresSubmenuLocal){ if(val) sensoresSubmenuLocal.classList.add('show'); else sensoresSubmenuLocal.classList.remove('show'); }
                if(sensoresToggleLocal){ sensoresToggleLocal.setAttribute('aria-expanded', (val? 'true':'false')); }
            }catch(e){}
            // change chevron direction
            const ic = toggle.querySelector('i'); if(ic) ic.className = val? 'bi bi-chevron-right' : 'bi bi-chevron-left';
            try{ localStorage.setItem('sidebarCollapsed', val? '1':'0'); }catch(e){}
          }
          // restore
          try{ const st = localStorage.getItem('sidebarCollapsed'); setCollapsed(st==='1'); }catch(e){}
          toggle.addEventListener('click', (e)=>{ e.preventDefault(); setCollapsed(!sidebar.classList.contains('collapsed')); });
        })();

        function loadGeneralPartial(){
          destroyAllCharts();
          cardsRow.innerHTML = '';
          const partialUrl = '/general/?partial=1&_=' + Date.now();
          fetch(partialUrl).then(r=>{ if(!r.ok) return r.text().then(t=>{throw new Error('Error general partial: '+r.status+' - '+t)}); return r.text(); }).then(html=>{
            // Parse the returned HTML and insert nodes
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            cardsRow.innerHTML = '';
            // Import all top-level children (this will include nested <script> tags, but they won't execute automatically)
            Array.from(doc.body.children).forEach(node=>{
                cardsRow.appendChild(document.importNode(node, true));
            });

            // Find any script tags within the inserted fragment and execute them manually.
            // This ensures inline scripts inside the partial run when inserted via fetch.
            const scripts = cardsRow.querySelectorAll('script');
            scripts.forEach(oldScript => {
                try{
                    const newScript = document.createElement('script');
                    // copy attributes
                    for(const attr of oldScript.attributes || []){ newScript.setAttribute(attr.name, attr.value); }
                    // copy inline content
                    newScript.text = oldScript.textContent;
                    // replace the old script with the new one so it executes
                    oldScript.parentNode.replaceChild(newScript, oldScript);
                }catch(e){ console.warn('Error ejecutando script del partial:', e); }
            });
      // Give the inserted scripts a moment to run, then request a redraw of general charts (if helper exists)
      setTimeout(()=>{ try{ if(window.__redrawGeneralCharts) window.__redrawGeneralCharts(); }catch(e){ console.warn('Error al forzar redraw general charts', e); } }, 150);
          }).catch(err=>{ console.error(err); cardsRow.innerHTML = '<div class="col-12"><div class="alert alert-danger">No se pudo cargar el dashboard general. Revisa la consola del servidor.</div></div>'; });
        }

                function saveState(state){
                    try{ localStorage.setItem('dashboardState', JSON.stringify(state)); }catch(e){ console.warn('No se pudo guardar estado en localStorage', e); }
                }

                function setActiveMenu(view,sensor){
                    const menuLinks = document.querySelectorAll('[data-view]');
                    menuLinks.forEach(l=>{
                        l.classList.remove('active');
                        const v = l.dataset.view; const s = l.dataset.sensor;
                        if(v===view){
                            if(view==='dashboard'){ l.classList.add('active'); }
                            else if(view==='sensor'){
                                // exact match sensor or 'all'
                                if(String(s)===String(sensor)) l.classList.add('active');
                            }
                        }
                    });
                    // manejar el estado del collapse del menú "Sensores"
                    const submenu = document.getElementById('sensoresSubmenu');
                    const toggleLink = document.querySelector('[data-bs-target="#sensoresSubmenu"]');
                    if(view==='sensor'){
                        if(submenu && !submenu.classList.contains('show')) submenu.classList.add('show');
                        if(toggleLink) toggleLink.setAttribute('aria-expanded','true');
                    } else {
                        if(submenu && submenu.classList.contains('show')) submenu.classList.remove('show');
                        if(toggleLink) toggleLink.setAttribute('aria-expanded','false');
                    }
                }

                function setLayoutForView(view, sensor){
                    // Always keep the panel centered to leave blank space to the right
                    const wrapper = document.querySelector('.dashboard-wrapper');
                    if(!wrapper) return;

                    // Si es la vista de un sensor específico (y NO es 'all')
                    if(view === 'sensor' && sensor && sensor !== 'all') {
                        // Alinear a la izquierda para que ocupe todo el ancho
                        wrapper.classList.remove('justify-content-center');
                        wrapper.classList.add('justify-content-start');
                    } else {
                        // Si es el dashboard general o la vista "Todos los Sensores"
                        // Mantener el layout centrado original
                        wrapper.classList.add('justify-content-center');
                        wrapper.classList.remove('justify-content-start');
                    }
                }

                function restoreState(){
                    try{
                        const raw = localStorage.getItem('dashboardState');
                        if(!raw) return loadSensors();
                        const state = JSON.parse(raw);
                        if(!state) return loadSensors();
                        if(state.view==='dashboard'){
                            setActiveMenu('dashboard', null);
                            setLayoutForView('dashboard');
                            loadSensors();
            } else if(state.view==='general'){
              setActiveMenu('general', null);
              setLayoutForView('dashboard');
              loadGeneralPartial();
                        } else if(state.view==='sensor'){
                            // if sensor is null or 'all', load all
                            if(!state.sensor || state.sensor==='all'){
                                setActiveMenu('sensor','all');
                                setLayoutForView('dashboard');
                                loadSensors();
                            } else {
                                setActiveMenu('sensor', state.sensor);
                                setLayoutForView('sensor');
                                loadSensor(state.sensor);
                            }
                        } else {
                            loadSensors();
                        }
                    }catch(e){ console.warn('No se pudo restaurar estado del dashboard', e); loadSensors(); }
                }

                function loadSensors(){
                    // remove any previous charts before replacing DOM
                    destroyAllCharts();
                    cardsRow.innerHTML = '';
                    const partialUrl = '/dashboard/partial/?_=' + Date.now();
                    const dataUrl = '/dashboard/data/?_=' + Date.now();
                    Promise.all([
                        fetch(partialUrl).then(r=>{ if(!r.ok) return r.text().then(t=>{throw new Error('Error partial: '+r.status+' - '+t)}); return r.text(); }),
                        fetch(dataUrl).then(r=>{ const ct = r.headers.get('content-type')||''; if(!r.ok) return r.text().then(t=>{throw new Error('Error data: '+r.status+' - '+t)}); if(ct.indexOf('application/json')===-1) return r.text().then(t=>{throw new Error('Respuesta data no JSON: '+t)}); return r.json(); })
                    ]).then(([partialHtml,data])=>{ cardsRow.innerHTML = partialHtml; initChartsFromData(data); }).catch(err=>{ console.error(err); cardsRow.innerHTML = '<div class="col-12"><div class="alert alert-danger">No se pudieron cargar los datos del dashboard. Revisa la consola para más detalles.</div></div>'; });
                }

                function loadSensor(sensorId){
                    // Cargar solo el partial del sensor solicitado para evitar que
                    // se rendericen todas las tarjetas y luego se oculten (parpadeo)
                    // destruir charts viejos antes de reemplazar el contenido
                    destroyAllCharts();
                    cardsRow.innerHTML = '';
                    const partialUrl = '/dashboard/partial/?sensor=' + encodeURIComponent(sensorId) + '&_=' + Date.now();
                    const dataUrl = '/dashboard/data/?_=' + Date.now();
                    Promise.all([
                        fetch(partialUrl).then(r=>{ if(!r.ok) return r.text().then(t=>{throw new Error('Error partial: '+r.status+' - '+t)}); return r.text(); }),
                        fetch(dataUrl).then(r=>{ const ct = r.headers.get('content-type')||''; if(!r.ok) return r.text().then(t=>{throw new Error('Error data: '+r.status+' - '+t)}); if(ct.indexOf('application/json')===-1) return r.text().then(t=>{throw new Error('Respuesta data no JSON: '+t)}); return r.json(); })
                    ]).then(([partialHtml,data])=>{ cardsRow.innerHTML = partialHtml; initChartsFromData(data); }).catch(err=>{ console.error(err); cardsRow.innerHTML = '<div class="col-12"><div class="alert alert-danger">No se pudieron cargar los datos del dashboard. Revisa la consola para más detalles.</div></div>'; });
                }

                function initChartsFromData(sensores_raw){
                    const grouped = sensores_raw.reduce((acc,r)=>{ const k = r.id_termocupla ?? 'unknown'; if(!acc[k]) acc[k]=[]; acc[k].push(r); return acc; }, {});
                    const now=new Date(); const hours=[]; for(let i=23;i>=0;i--){ const h=new Date(now); h.setMinutes(0,0,0); h.setHours(now.getHours()-i); hours.push(h);} const labels24 = hours.map(d=> (d.getHours()<10? '0'+d.getHours():d.getHours())+':00');

                    const cards = cardsRow.querySelectorAll('.sensor-card');
                    cards.forEach(card=>{
                        const sensorId = card.dataset.sensor;
                        const readings = (grouped[sensorId]||[]).slice().sort((a,b)=> new Date(a.fecha_hora)-new Date(b.fecha_hora));
                        const hourlyAvg = hours.map(h=>{ const end=new Date(h); end.setHours(h.getHours()+1); const slot = readings.map(r=>({d:new Date(r.fecha_hora),t: Number(r.temperatura)})).filter(x=>!isNaN(x.t) && x.d>=h && x.d<end).map(x=>x.t); if(!slot.length) return null; const s=slot.reduce((a,b)=>a+b,0); return +(s/slot.length).toFixed(2); });
                        const getHumidityValue = r=> Number(r.humedad ?? r.humedad_relativa ?? r.humidity ?? r.hum ?? r.humedad_porcentaje ?? NaN);
                        const hourlyHum = hours.map(h=>{ const end=new Date(h); end.setHours(h.getHours()+1); const slot = readings.map(r=>({d:new Date(r.fecha_hora),h:getHumidityValue(r)})).filter(x=>!isNaN(x.h) && x.d>=h && x.d<end).map(x=>x.h); if(!slot.length) return null; const s=slot.reduce((a,b)=>a+b,0); return +(s/slot.length).toFixed(2); });

                        // Use hourly averages for charting, but compute min/max from raw readings (DB) so displayed Min/Max match the DB values
                        const temps = hourlyAvg.filter(v=>v!==null);
                        const overallAvg = temps.length?+(temps.reduce((a,b)=>a+b,0)/temps.length).toFixed(2):null;
                        const hums = hourlyHum.filter(v=>v!==null);
                        const overallHumAvg = hums.length?+(hums.reduce((a,b)=>a+b,0)/hums.length).toFixed(2):null;

                        // raw values from DB
                        const tempsRaw = readings.map(r=>{ const t = Number(r.temperatura); return isNaN(t)?null:t; }).filter(x=>x!==null);
                        const minTemp = tempsRaw.length?Math.min(...tempsRaw):null;
                        const maxTemp = tempsRaw.length?Math.max(...tempsRaw):null;
                        const humsRaw = readings.map(r=>{ const h = getHumidityValue(r); return isNaN(h)?null:h; }).filter(x=>x!==null);
                        const minHum = humsRaw.length?Math.min(...humsRaw):null;
                        const maxHum = humsRaw.length?Math.max(...humsRaw):null;
                        const lastReading = readings[readings.length-1];

                        // small helper to format numbers with decimals for display
                        const formatNumber = (v, decimals=2) => { if(v===null || v===undefined || v==='' || Number.isNaN(Number(v))) return '--'; const n = Number(v); return n.toFixed(1); };

                        const lastEl = card.querySelector('.last-reading'); if(lastEl) lastEl.textContent = 'Última: ' + (lastReading? new Date(lastReading.fecha_hora).toLocaleString() : '--');
                        const tipoParedEl = card.querySelector('.tipo-pared'); if(tipoParedEl) tipoParedEl.textContent = readings[0]?.tipo_pared ?? '--';
                        const curTempEl = card.querySelector('.current-temp'); if(curTempEl) curTempEl.textContent = lastReading? formatNumber(lastReading.temperatura, 1) : '--' + '</strong> °C';
                        const curHumEl = card.querySelector('.current-hum'); if(curHumEl) curHumEl.textContent = lastReading? formatNumber(getHumidityValue(lastReading), 1) : '--';
                        const minMaxTemp = card.querySelector('.min-max-temp'); if(minMaxTemp) minMaxTemp.innerHTML = 'Min: <strong>' + (minTemp!==null?formatNumber(minTemp,1):'--') + '</strong> °C — Max: <strong>' + (maxTemp!==null?formatNumber(maxTemp,1):'--') + '</strong> °C';
                        const minMaxHum = card.querySelector('.min-max-hum'); if(minMaxHum) minMaxHum.innerHTML = 'Min H: <strong>' + (minHum!==null?formatNumber(minHum,1):'--') + '</strong>% — Max H: <strong>' + (maxHum!==null?formatNumber(maxHum,1):'--') + '</strong>%';
                        const avgT = card.querySelector('.avg-t'); if(avgT) avgT.innerHTML = 'Promedio T: <strong>' + (overallAvg!==null?formatNumber(overallAvg,1):'--') + '</strong> °C';
                        const avgH = card.querySelector('.avg-h'); if(avgH) avgH.innerHTML = 'Promedio H: <strong>' + (overallHumAvg!==null?formatNumber(overallHumAvg,1):'--') + '</strong> %';
                                    const canvasTemp = card.querySelector('canvas[id^="chart-temp"]');
                                    const canvasHum = card.querySelector('canvas[id^="chart-hum"]');
                                    try{
                                        if(canvasTemp){
                                            const ctxT = canvasTemp.getContext('2d');
                                            const heightT = canvasTemp.height || canvasTemp.clientHeight || 260;
                                            const gradientT = ctxT.createLinearGradient(0,0,0,heightT);
                                            gradientT.addColorStop(0,'rgba(13,110,253,0.22)'); gradientT.addColorStop(0.6,'rgba(13,110,253,0.08)'); gradientT.addColorStop(1,'rgba(13,110,253,0.02)');
                                            const datasetTemp = {
                                                label: 'Temperatura promedio por hora (°C)',
                                                data: hourlyAvg,
                                                borderColor: '#0d6efd',
                                                backgroundColor: gradientT,
                                                tension: 0.35,
                                                fill: true,
                                                pointRadius: 0,
                                                pointBackgroundColor: '#fff',
                                                pointBorderColor: '#0d6efd',
                                                pointHoverRadius: 6,
                                                spanGaps: false,
                                                borderWidth: 2,
                                                yAxisID: 'y'
                                            };

                                            const createdChartT = new Chart(ctxT, {
                                                type: 'line',
                                                data: { labels: labels24, datasets: [datasetTemp] },
                                                options: {
                                                    animation: false,
                                                    responsive: true,
                                                    maintainAspectRatio: false,
                                                    interaction: { mode: 'nearest', intersect: false },
                                                    elements: { point: { radius: 0, hoverRadius: 6 }, line: { borderCapStyle: 'round' } },
                                                    plugins: {
                                                        legend: { display: false },
                                                        tooltip: {
                                                            backgroundColor: '#ffffff', titleColor: '#111827', bodyColor: '#111827', borderColor: '#e9ecef', borderWidth: 1, padding: 8,
                                                            callbacks: {
                                                                title(items){ return items[0].label; },
                                                                label(context){ const val = context.raw; return (val === null || val === undefined) ? 'Sin datos' : `Temperatura: ${val} °C`; }
                                                            }
                                                        },
                                                        layout: { padding: { top: 6 } }
                                                    },
                                                    scales: {
                                                        x: { ticks: { autoSkip: true, maxTicksLimit: 12, maxRotation: 0, font: { size: 11 }, color: '#6b7280', callback(value, index){ return this.chart && this.chart.data && this.chart.data.labels ? this.chart.data.labels[index] : value; } }, grid: { display: false } },
                                                        y: { beginAtZero: false, suggestedMin: (minTemp !== null ? Math.floor(minTemp - 2) : undefined), suggestedMax: (maxTemp !== null ? Math.ceil(maxTemp + 2) : undefined), grid: { color: 'rgba(15,23,42,0.04)' }, position: 'left', ticks: { color: '#6b7280', font: { size: 11 } } }
                                                    }
                                                }
                                            });
                                            try{ if(canvasTemp && canvasTemp.id) chartInstances[canvasTemp.id] = createdChartT; }
                                            catch(e){ /* ignore */ }
                                        }

                                        if(canvasHum){
                                            const ctxH = canvasHum.getContext('2d');
                                            const heightH = canvasHum.height || canvasHum.clientHeight || 220;
                                            const gradientH = ctxH.createLinearGradient(0,0,0,heightH);
                                            gradientH.addColorStop(0,'rgba(32,201,151,0.18)'); gradientH.addColorStop(0.6,'rgba(32,201,151,0.08)'); gradientH.addColorStop(1,'rgba(32,201,151,0.02)');
                                            const datasetHumOnly = {
                                                label: 'Humedad promedio por hora (%)',
                                                data: hourlyHum,
                                                borderColor: '#20c997',
                                                backgroundColor: gradientH,
                                                tension: 0.25,
                                                fill: true,
                                                pointRadius: 0,
                                                pointBackgroundColor: '#20c997',
                                                pointBorderColor: '#fff',
                                                pointHoverRadius: 5,
                                                spanGaps: false,
                                                borderWidth: 2,
                                                yAxisID: 'y1'
                                            };

                                            const createdChartH = new Chart(ctxH, {
                                                type: 'line',
                                                data: { labels: labels24, datasets: [datasetHumOnly] },
                                                options: {
                                                    animation: false,
                                                    responsive: true,
                                                    maintainAspectRatio: false,
                                                    interaction: { mode: 'nearest', intersect: false },
                                                    elements: { point: { radius: 0, hoverRadius: 5 }, line: { borderCapStyle: 'round' } },
                                                    plugins: { legend: { display: false }, tooltip: { backgroundColor: '#ffffff', titleColor: '#111827', bodyColor: '#111827', borderColor: '#e9ecef', borderWidth: 1, padding: 8, callbacks: { title(items){ return items[0].label; }, label(context){ const val = context.raw; return (val === null || val === undefined) ? 'Sin datos' : `Humedad: ${val} %`; } } }, layout: { padding: { top: 6 } } },
                                                    scales: {
                                                        x: { ticks: { autoSkip: true, maxTicksLimit: 12, maxRotation: 0, font: { size: 11 }, color: '#6b7280', callback(value, index){ return this.chart && this.chart.data && this.chart.data.labels ? this.chart.data.labels[index] : value; } }, grid: { display: false } },
                                                        y1: { beginAtZero: true, suggestedMin: (minHum !== null ? Math.max(0, Math.floor(minHum - 5)) : undefined), suggestedMax: (maxHum !== null ? Math.min(100, Math.ceil(maxHum + 5)) : undefined), grid: { display: false }, position: 'left', ticks: { callback(v){ return v + ' %'; }, color: '#6b7280', font: { size: 11 } } }
                                                    }
                                                }
                                            });
                                            try{ if(canvasHum && canvasHum.id) chartInstances[canvasHum.id] = createdChartH; }
                                            catch(e){ /* ignore */ }
                                        }
                                    }catch(e){ console.error('Error creando charts (partial)', e); }
                                    });

                                    // Force initial resize/redraw now and shortly after to handle layout/docking changes
                                    try{ handleResize(); setTimeout(handleResize, 200); }catch(e){ /* ignore */ }
                }

        // initialize: attach menu handlers then restore last view from localStorage
        setupMenu();

        // Ensure the 'Sensores' collapse toggle works reliably (works even if bootstrap data attributes fail)
        try{
          const sensoresToggle = document.querySelector('[data-bs-target="#sensoresSubmenu"]');
          const sensoresSubmenu = document.getElementById('sensoresSubmenu');
          if(sensoresToggle && sensoresSubmenu){
            // remove bootstrap data attributes to avoid double-handling by data-api
            try{ sensoresToggle.removeAttribute('data-bs-toggle'); sensoresToggle.removeAttribute('data-bs-target'); }catch(e){}
            sensoresToggle.addEventListener('click', function(ev){
              ev.preventDefault();
              // stop other handlers (including bootstrap's) from receiving this click
              try{ ev.stopImmediatePropagation(); }catch(e){}
              // If sidebar is collapsed, keep submenu visible and do not toggle
              const sidebarEl = document.getElementById('sidebar');
              if(sidebarEl && sidebarEl.classList.contains('collapsed')){
                sensoresSubmenu.classList.add('show');
                sensoresToggle.setAttribute('aria-expanded','true');
                return;
              }
              // toggle the submenu manually
              sensoresSubmenu.classList.toggle('show');
              const expanded = sensoresSubmenu.classList.contains('show');
              sensoresToggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
            });
          }
        }catch(e){ console.warn('No se pudo inicializar el toggle Sensores', e); }

        // Event delegation fallback: handle clicks on any element with [data-view]
        // This ensures links inside collapsed/Bootstrap-collapsed containers work reliably
        document.addEventListener('click', function(ev){
          const a = ev.target.closest('[data-view]');
          if(!a) return;
          ev.preventDefault();
          // remove active from other menu items and set this one
          const menuLinks = document.querySelectorAll('[data-view]');
          menuLinks.forEach(l=>l.classList.remove('active'));
          a.classList.add('active');
          const view = a.dataset.view; const sensor = a.dataset.sensor;
          if(view==='general'){
            saveState({view:'general', sensor:null}); setLayoutForView('dashboard'); loadGeneralPartial();
          } else if(view==='dashboard'){
            saveState({view:'dashboard', sensor:null}); setLayoutForView('dashboard'); loadSensors();
          } else if(view==='sensor'){
            saveState({view:'sensor', sensor: sensor}); setLayoutForView('sensor'); if(sensor==='all') loadSensors(); else loadSensor(sensor);
          }
        });

        restoreState();
            })();
        </script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    </body>
</html>