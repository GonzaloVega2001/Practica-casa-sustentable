{% load static %}
<!doctype html>
<html lang="es">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Dashboard-Termocuplas</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
        <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    </head>

    <body >
        <!-- Cabecera con logos alineados extremos y título debajo -->
        <div class="container">
                <div class="row align-items-center mb-2">
                    <div class="col-6 d-flex justify-content-start">
                        <img src="{% static 'img/logoupla.png' %}" alt="Logo UPLA" style="height:54px; width:140px; object-fit:contain;" />
                    </div>
                    <div class="col-6 d-flex justify-content-end">
                        <img src="{% static 'img/logolaptes.png' %}" alt="Logo Proyecto" style="height:120px; width:100px; object-fit:contain;" />
                    </div>
                </div>
                <div class="row mb-3">
                    <div class="col-12 text-center">
                        <h1 class="h3 mb-0"><i class="bi bi-speedometer2"></i> Dashboard de Sensores</h1>
                        <small class="text-muted">Visualización de temperaturas</small>
                    </div>
                </div>
                <div id="cards-row" class="row gy-4">
                </div>
            </div>
        </div>
        <br>
        <footer class="bg-dark text-light">
                            <div class="container py-3">
                                <div class="d-flex justify-content-center">
                                    <small id="footer-info">Sitio LAPTES-FING desarrollado por
                                        <a href="https://www.upla.cl/noticias/contactanos/" target="_blank" class="text-white fw-bold text-decoration-none ms-1">Dirección General de Comunicaciones</a>
                                    </small>
                                </div>
                            </div>
                        </footer>
        
        <script type="text/javascript">
            // sensores_json debe ser una cadena JSON desde Django (ver vista)
            let sensores_raw = [];
            try {
                sensores_raw = JSON.parse('{{ sensores_json|escapejs }}' || '[]');
            } catch (e) {
                console.error('Error parsing sensores JSON:', e);
                sensores_raw = [];
            }

            // Actualiza la marca de tiempo del último dato visible
            (function updateLast() {
                if (!sensores_raw.length) return;
                const latest = sensores_raw.reduce((a,b) => {
                    return new Date(a.fecha_hora) > new Date(b.fecha_hora) ? a : b;
                });
                const el = document.getElementById('last-update');
                if (el) {
                    const d = new Date(latest.fecha_hora);
                    el.textContent = isNaN(d) ? latest.fecha_hora : d.toLocaleString();
                }
            })();

            // Agrupar lecturas por id_termocupla
            const grouped = sensores_raw.reduce((acc, r) => {
                const key = r.id_termocupla ?? 'unknown';
                if (!acc[key]) acc[key] = [];
                acc[key].push(r);
                return acc;
            }, {});

            const cardsRow = document.getElementById('cards-row');

            // Helper: formato hora HH:00
            function pad(n){ return n < 10 ? '0' + n : String(n); }
            function formatHourLabel(d){ return pad(d.getHours()) + ':00'; }

            // Crear etiquetas para las últimas 24 horas (orden ascendente)
            const now = new Date();
            const hours = [];
            for (let i = 23; i >= 0; i--) {
                const h = new Date(now);
                h.setMinutes(0,0,0);
                h.setHours(now.getHours() - i);
                hours.push(h);
            }
            const labels24 = hours.map(formatHourLabel);

            const _sensorKeys = Object.keys(grouped);
            const _totalSensors = _sensorKeys.length;
            _sensorKeys.forEach((sensorId, idx) => {
                const readings = grouped[sensorId];

                // Ordenar por fecha (ascendente)
                readings.sort((a, b) => new Date(a.fecha_hora) - new Date(b.fecha_hora));

                // Calcular promedio por hora para las últimas 24 horas (temperatura)
                const hourlyAvg = hours.map(hourStart => {
                    const hourEnd = new Date(hourStart);
                    hourEnd.setHours(hourStart.getHours() + 1);
                    const slot = readings
                        .map(r => ({ d: new Date(r.fecha_hora), t: Number(r.temperatura) }))
                        .filter(x => !isNaN(x.t) && x.d >= hourStart && x.d < hourEnd)
                        .map(x => x.t);
                    if (!slot.length) return null;
                    const s = slot.reduce((a,b) => a + b, 0);
                    return +(s / slot.length).toFixed(2);
                });

                // Calcular promedio por hora para humedad (intenta varias claves posibles)
                function getHumidityValue(r){
                    // posibles nombres de campo en los datos
                    return Number(r.humedad ?? r.humedad_relativa ?? r.humidity ?? r.hum ?? r.humedad_porcentaje ?? NaN);
                }
                const hourlyHum = hours.map(hourStart => {
                    const hourEnd = new Date(hourStart);
                    hourEnd.setHours(hourStart.getHours() + 1);
                    const slot = readings
                        .map(r => ({ d: new Date(r.fecha_hora), h: getHumidityValue(r) }))
                        .filter(x => !isNaN(x.h) && x.d >= hourStart && x.d < hourEnd)
                        .map(x => x.h);
                    if (!slot.length) return null;
                    const s = slot.reduce((a,b) => a + b, 0);
                    return +(s / slot.length).toFixed(2);
                });

                // Estadísticas simples sobre los valores mostrados (temperatura)
                const temps = hourlyAvg.filter(v => v !== null);
                const minTemp = temps.length ? Math.min(...temps) : 0;
                const maxTemp = temps.length ? Math.max(...temps) : 0;
                const overallAvg = temps.length ? +(temps.reduce((a,b)=>a+b,0)/temps.length).toFixed(2) : null;

                // Estadísticas para humedad
                const hums = hourlyHum.filter(v => v !== null);
                const minHum = hums.length ? Math.min(...hums) : 0;
                const maxHum = hums.length ? Math.max(...hums) : 0;
                const overallHumAvg = hums.length ? +(hums.reduce((a,b)=>a+b,0)/hums.length).toFixed(2) : null;

                // Última lectura cruda (para mostrar valor actual)
                const lastReading = readings[readings.length - 1];
                const tipoPared = readings[0]?.tipo_pared ?? 'N/D';

                // Crear columna y tarjeta
                const col = document.createElement('div');
                // Un sensor por fila: ocupar todo el ancho
                col.className = 'col-12 mb-3';

                const card = document.createElement('div');
                card.className = 'card sensor-card h-100';

                const header = document.createElement('div');
                header.className = 'card-header custom py-2 px-3 d-flex justify-content-between align-items-start';

                const headerLeft = document.createElement('div');
                headerLeft.innerHTML = `<strong>Termocupla ${sensorId}</strong><div class="small-muted">Última: ${lastReading ? new Date(lastReading.fecha_hora).toLocaleString() : '--'}</div>`;

                const headerRight = document.createElement('div');
                // Se quitan las badges/botones; solo mostrar tipo de pared en texto pequeño
                headerRight.innerHTML = `<div class="circle-label">${tipoPared}</div>`;

                header.appendChild(headerLeft);
                header.appendChild(headerRight);

                const cardBody = document.createElement('div');
                cardBody.className = 'card-body d-flex flex-column';

                const info = document.createElement('p');
                info.className = 'card-text mb-2 small-muted';
                // obtener humedad actual (si existe en la lectura)
                const currentHum = lastReading ? (getHumidityValue(lastReading)) : null;
                const humText = (currentHum !== null && !isNaN(currentHum)) ? `${currentHum} %` : '--';
                info.innerHTML = `Temperatura actual: <strong>${lastReading ? lastReading.temperatura : '--'} °C</strong> — Humedad: <strong>${humText}</strong>`;

                const chartWrap = document.createElement('div');
                chartWrap.className = 'chart-container mb-2';

                const canvas = document.createElement('canvas');
                const canvasId = `chart-sensor-${sensorId}-${idx}`;
                canvas.id = canvasId;
                canvas.style.width = '100%';
                // altura fija para que cada tarjeta tenga una gráfica consistente
                canvas.style.height = '260px';

                chartWrap.appendChild(canvas);
                cardBody.appendChild(info);
                cardBody.appendChild(chartWrap);

                const footer = document.createElement('div');
                footer.className = 'card-footer d-flex justify-content-between align-items-center py-2 flex-wrap';
                // Mostrar min/max temperatura y min/max humedad
                footer.innerHTML = `<div class="footer-note">Min: <strong>${minTemp}</strong> °C — Max: <strong>${maxTemp}</strong> °C</div><div class="footer-note">Min H: <strong>${minHum}</strong>% — Max H: <strong>${maxHum}</strong>%</div>`;
                if (overallAvg !== null) {
                    const avgEl = document.createElement('div');
                    avgEl.className = 'ms-2';
                    avgEl.innerHTML = `Promedio T: <strong>${overallAvg}</strong> °C`;
                    footer.appendChild(avgEl);
                }
                if (overallHumAvg !== null) {
                    const avgHel = document.createElement('div');
                    avgHel.className = 'ms-2';
                    avgHel.innerHTML = `Promedio H: <strong>${overallHumAvg}</strong> %`;
                    footer.appendChild(avgHel);
                }

                card.appendChild(header);
                card.appendChild(cardBody);
                card.appendChild(footer);
                col.appendChild(card);
                cardsRow.appendChild(col);

                // insertar separador horizontal entre tarjetas (excepto después del último)
                if (idx < _totalSensors - 1) {
                    const sep = document.createElement('hr');
                    sep.className = 'my-3';
                    // estilado sutil
                    sep.style.border = '0';
                    sep.style.borderTop = '1px solid rgba(0,0,0,0.08)';
                    cardsRow.appendChild(sep);
                }

                // Crear grafico con gradiente para la serie promedio por hora
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height || 260);
                gradient.addColorStop(0, 'rgba(13,110,253,0.22)');
                gradient.addColorStop(0.6, 'rgba(13,110,253,0.08)');
                gradient.addColorStop(1, 'rgba(13,110,253,0.02)');

                const datasetMain = {
                    label: 'Temperatura promedio por hora (°C)',
                    data: hourlyAvg,
                    borderColor: '#0d6efd',
                    backgroundColor: gradient,
                    tension: 0.35,
                    fill: true,
                    pointRadius: 4,
                    pointBackgroundColor: '#fff',
                    pointBorderColor: '#0d6efd',
                    pointHoverRadius: 6,
                    spanGaps: true,
                    borderWidth: 2,
                    yAxisID: 'y',
                };

                // dataset de humedad (segunda serie)
                const datasetHum = {
                    label: 'Humedad promedio por hora (%)',
                    data: hourlyHum,
                    borderColor: '#20c997',
                    backgroundColor: 'rgba(32,201,151,0.08)',
                    tension: 0.25,
                    fill: false,
                    pointRadius: 3,
                    pointBackgroundColor: '#20c997',
                    pointBorderColor: '#fff',
                    pointHoverRadius: 5,
                    spanGaps: true,
                    borderWidth: 2,
                    yAxisID: 'y1',
                };

                const datasets = [datasetMain, datasetHum];

                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels24,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'nearest', intersect: false },
                        plugins: {
                            // Ocultar leyenda para eliminar los botones interactivos
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    title(items) { return items[0].label; },
                                    label(context) {
                                        const val = context.raw;
                                        const label = context.dataset && context.dataset.label ? context.dataset.label.toLowerCase() : '';
                                        if (val === null || val === undefined) return 'Sin datos';
                                        if (label.includes('humedad')) return `Humedad: ${val} %`;
                                        return `Temperatura: ${val} °C`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                // Mostrar las 24 horas (sin auto-skip) para que aparezca una etiqueta por hora
                                ticks: {
                                    autoSkip: false,
                                    maxRotation: 0,
                                    // usar tamaño de fuente más pequeño para evitar solapamientos
                                    font: { size: 11 },
                                    callback(value, index) {
                                        // `this.chart.data.labels` contiene las etiquetas horarias
                                        return this.chart && this.chart.data && this.chart.data.labels ? this.chart.data.labels[index] : value;
                                    }
                                },
                                grid: { display: false }
                            },
                            y: {
                                beginAtZero: false,
                                suggestedMin: Math.floor(minTemp - 2),
                                suggestedMax: Math.ceil(maxTemp + 2),
                                grid: { color: 'rgba(15,23,42,0.04)' },
                                position: 'left',
                            },
                            y1: {
                                beginAtZero: true,
                                suggestedMin: Math.max(0, Math.floor(minHum - 5)),
                                suggestedMax: Math.min(100, Math.ceil(maxHum + 5)),
                                grid: { display: false },
                                position: 'right',
                                ticks: { callback(v){ return v + ' %'; } }
                            }
                        }
                    }
                });
            });
        </script>

        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    </body>
</html>