{% load static %}
<!doctype html>
<html lang="es">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Dashboard-Termocuplas</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
        <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    </head>

    <body >
            <!-- Cabecera con logos alineados extremos y título debajo -->
        <div class="container">
                <div class="row align-items-center mb-2">
                    <div class="col-6 d-flex justify-content-start">
                        <img src="{% static 'img/logoupla.png' %}" alt="Logo UPLA" style="height:54px; width:140px; object-fit:contain;" />
                    </div>
                    <div class="col-6 d-flex justify-content-end">
                        <img src="{% static 'img/logolaptes.png' %}" alt="Logo Proyecto" style="height:120px; width:100px; object-fit:contain;" />
                    </div>
                </div>
                <div class="row mb-3">
                    <div class="col-12 text-center">
                        <h1 class="h3 mb-0"><i class="bi bi-speedometer2"></i> Dashboard de Sensores</h1>
                        <small class="text-muted">Visualización de temperaturas</small>
                    </div>
                </div>
                <div id="cards-row" class="row gy-4">
                </div>
            </div>
        </div>
        <br>
        <footer class="bg-dark text-light">
                            <div class="container py-3">
                                <div class="d-flex justify-content-center">
                                    <small id="footer-info">Sitio LAPTES-FING desarrollado por
                                        <a href="https://www.upla.cl/noticias/contactanos/" target="_blank" class="text-white fw-bold text-decoration-none ms-1">Dirección General de Comunicaciones</a>
                                    </small>
                                </div>
                            </div>
        </footer>
        
        <script type="text/javascript">
            // sensores_json debe ser una cadena JSON desde Django (ver vista)
            let sensores_raw = [];
            try {
                sensores_raw = JSON.parse('{{ sensores_json|escapejs }}' || '[]');
            } catch (e) {
                console.error('Error parsing sensores JSON:', e);
                sensores_raw = [];
            }

            // Actualiza la marca de tiempo del último dato visible
            (function updateLast() {
                if (!sensores_raw.length) return;
                const latest = sensores_raw.reduce((a,b) => {
                    return new Date(a.fecha_hora) > new Date(b.fecha_hora) ? a : b;
                });
                const el = document.getElementById('last-update');
                if (el) {
                    const d = new Date(latest.fecha_hora);
                    el.textContent = isNaN(d) ? latest.fecha_hora : d.toLocaleString();
                }
            })();

            // Agrupar lecturas por id_termocupla
            const grouped = sensores_raw.reduce((acc, r) => {
                const key = r.id_termocupla ?? 'unknown';
                if (!acc[key]) acc[key] = [];
                acc[key].push(r);
                return acc;
            }, {});

            const cardsRow = document.getElementById('cards-row');

            // Helper: formato hora HH:00
            function pad(n){ return n < 10 ? '0' + n : String(n); }
            function formatHourLabel(d){ return pad(d.getHours()) + ':00'; }

            // Crear etiquetas para las últimas 24 horas (orden ascendente)
            const now = new Date();
            const hours = [];
            for (let i = 23; i >= 0; i--) {
                const h = new Date(now);
                h.setMinutes(0,0,0);
                h.setHours(now.getHours() - i);
                hours.push(h);
            }
            const labels24 = hours.map(formatHourLabel);

            const _sensorKeys = Object.keys(grouped);
            const _totalSensors = _sensorKeys.length;
            _sensorKeys.forEach((sensorId, idx) => {
                const readings = grouped[sensorId];

                // Ordenar por fecha (ascendente)
                readings.sort((a, b) => new Date(a.fecha_hora) - new Date(b.fecha_hora));

                // Calcular promedio por hora para las últimas 24 horas (temperatura)
                const hourlyAvg = hours.map(hourStart => {
                    const hourEnd = new Date(hourStart);
                    hourEnd.setHours(hourStart.getHours() + 1);
                    const slot = readings
                        .map(r => ({ d: new Date(r.fecha_hora), t: Number(r.temperatura) }))
                        .filter(x => !isNaN(x.t) && x.d >= hourStart && x.d < hourEnd)
                        .map(x => x.t);
                    if (!slot.length) return null;
                    const s = slot.reduce((a,b) => a + b, 0);
                    return +(s / slot.length).toFixed(2);
                });

                // Calcular promedio por hora para humedad (intenta varias claves posibles)
                function getHumidityValue(r){
                    // posibles nombres de campo en los datos
                    return Number(r.humedad ?? r.humedad_relativa ?? r.humidity ?? r.hum ?? r.humedad_porcentaje ?? NaN);
                }
                const hourlyHum = hours.map(hourStart => {
                    const hourEnd = new Date(hourStart);
                    hourEnd.setHours(hourStart.getHours() + 1);
                    const slot = readings
                        .map(r => ({ d: new Date(r.fecha_hora), h: getHumidityValue(r) }))
                        .filter(x => !isNaN(x.h) && x.d >= hourStart && x.d < hourEnd)
                        .map(x => x.h);
                    if (!slot.length) return null;
                    const s = slot.reduce((a,b) => a + b, 0);
                    return +(s / slot.length).toFixed(2);
                });

                // Estadísticas simples sobre los valores mostrados (temperatura)
                const temps = hourlyAvg.filter(v => v !== null);
                const minTemp = temps.length ? Math.min(...temps) : null;
                const maxTemp = temps.length ? Math.max(...temps) : null;
                const overallAvg = temps.length ? +(temps.reduce((a,b)=>a+b,0)/temps.length).toFixed(2) : null;

                // Estadísticas para humedad
                const hums = hourlyHum.filter(v => v !== null);
                const minHum = hums.length ? Math.min(...hums) : null;
                const maxHum = hums.length ? Math.max(...hums) : null;
                const overallHumAvg = hums.length ? +(hums.reduce((a,b)=>a+b,0)/hums.length).toFixed(2) : null;

                // Última lectura cruda (para mostrar valor actual)
                const lastReading = readings[readings.length - 1];
                const tipoPared = readings[0]?.tipo_pared ?? 'N/D';

                // Crear columna y tarjeta
                const col = document.createElement('div');
                // Cada sensor ocupa una columna; en pantallas md aparecen 2 columnas por fila
                col.className = 'col-12 col-md-12 mb-3';

                const card = document.createElement('div');
                card.className = 'card sensor-card h-100';

                const header = document.createElement('div');
                header.className = 'card-header custom py-2 px-3 d-flex justify-content-between align-items-start';

                const headerLeft = document.createElement('div');
                headerLeft.innerHTML = `<strong>Termocupla ${sensorId}</strong><div class="small-muted">Última: ${lastReading ? new Date(lastReading.fecha_hora).toLocaleString() : '--'}</div>`;

                const headerRight = document.createElement('div');
                // Se quitan las badges/botones; solo mostrar tipo de pared en texto pequeño
                headerRight.innerHTML = `<div class="circle-label">${tipoPared}</div>`;

                header.appendChild(headerLeft);
                header.appendChild(headerRight);

                const cardBody = document.createElement('div');
                cardBody.className = 'card-body d-flex flex-column';

                const info = document.createElement('p');
                info.className = 'card-text mb-2 small-muted';
                // obtener humedad actual (si existe en la lectura)
                const currentHum = lastReading ? (getHumidityValue(lastReading)) : null;
                const humText = (currentHum !== null && !isNaN(currentHum)) ? `${currentHum} %` : '--';
                info.innerHTML = `Temperatura actual: <strong>${lastReading ? lastReading.temperatura : '--'} °C</strong> — Humedad: <strong>${humText}</strong>`;

                // Crear contenedor responsivo: usar una fila Bootstrap con dos columnas
                const chartRow = document.createElement('div');
                chartRow.className = 'chart-row mb-2 chart-container';

                // Crear inner row que contendrá las dos columnas de los charts
                const innerRow = document.createElement('div');
                innerRow.className = 'row g-2 align-items-start';

                // Crear dos canvas: uno para temperatura y otro para humedad
                const canvasTemp = document.createElement('canvas');
                const canvasTempId = `chart-temp-${sensorId}-${idx}`;
                canvasTemp.id = canvasTempId;
                canvasTemp.classList.add('chart-temp-canvas', 'w-100');

                const canvasHum = document.createElement('canvas');
                const canvasHumId = `chart-hum-${sensorId}-${idx}`;
                canvasHum.id = canvasHumId;
                canvasHum.classList.add('chart-hum-canvas', 'w-100');

                // Columnas Bootstrap para que cada canvas ocupe la mitad del ancho en sm+
                const colLeft = document.createElement('div');
                colLeft.className = 'col-12 col-sm-6';
                colLeft.appendChild(canvasTemp);

                const colRight = document.createElement('div');
                colRight.className = 'col-12 col-sm-6';
                colRight.appendChild(canvasHum);

                // Añadir en orden: info, leyenda combinada, fila de dos columnas
                cardBody.appendChild(info);
                const legendDiv = document.createElement('div');
                legendDiv.className = 'combined-legend mb-2 d-flex justify-content-center gap-3';
                legendDiv.innerHTML = `<div class="legend-item"><span class="legend-dot" style="background:#0d6efd"></span> Temperatura</div><div class="legend-item"><span class="legend-dot" style="background:#20c997"></span> Humedad</div>`;
                cardBody.appendChild(legendDiv);
                innerRow.appendChild(colLeft);
                innerRow.appendChild(colRight);
                chartRow.appendChild(innerRow);
                cardBody.appendChild(chartRow);

                const footer = document.createElement('div');
                footer.className = 'card-footer d-flex justify-content-between align-items-center py-2 flex-wrap';
                // Mostrar min/max temperatura y min/max humedad (usar -- si no hay datos)
                const minTempText = (minTemp !== null) ? minTemp : '--';
                const maxTempText = (maxTemp !== null) ? maxTemp : '--';
                const minHumText = (minHum !== null) ? minHum : '--';
                const maxHumText = (maxHum !== null) ? maxHum : '--';
                footer.innerHTML = `<div class="footer-note">Min: <strong>${minTempText}</strong> °C — Max: <strong>${maxTempText}</strong> °C</div><div class="footer-note">Min H: <strong>${minHumText}</strong>% — Max H: <strong>${maxHumText}</strong>%</div>`;
                if (overallAvg !== null) {
                    const avgEl = document.createElement('div');
                    avgEl.className = 'ms-2';
                    avgEl.innerHTML = `Promedio T: <strong>${overallAvg}</strong> °C`;
                    footer.appendChild(avgEl);
                }
                if (overallHumAvg !== null) {
                    const avgHel = document.createElement('div');
                    avgHel.className = 'ms-2';
                    avgHel.innerHTML = `Promedio H: <strong>${overallHumAvg}</strong> %`;
                    footer.appendChild(avgHel);
                }

                card.appendChild(header);
                card.appendChild(cardBody);
                card.appendChild(footer);
                col.appendChild(card);
                cardsRow.appendChild(col);

                // insertar separador horizontal entre tarjetas (excepto después del último)
                if (idx < _totalSensors - 1) {
                    const sep = document.createElement('hr');
                    sep.className = 'my-3';
                    // estilado sutil
                    sep.style.border = '0';
                    sep.style.borderTop = '1px solid rgba(0,0,0,0.08)';
                    cardsRow.appendChild(sep);
                }

                // TEMPERATURA: crear gráfico separado
                const ctxT = canvasTemp.getContext('2d');
                // usar clientHeight si canvas.height no está inicializado
                const heightT = canvasTemp.height || canvasTemp.clientHeight || 180;
                const gradientT = ctxT.createLinearGradient(0, 0, 0, heightT);
                gradientT.addColorStop(0, 'rgba(13,110,253,0.22)');
                gradientT.addColorStop(0.6, 'rgba(13,110,253,0.08)');
                gradientT.addColorStop(1, 'rgba(13,110,253,0.02)');

                const datasetTemp = {
                    label: 'Temperatura promedio por hora (°C)',
                    data: hourlyAvg,
                    borderColor: '#0d6efd',
                    backgroundColor: gradientT,
                    tension: 0.35,
                    fill: true,
                    pointRadius: 0,
                    pointBackgroundColor: '#fff',
                    pointBorderColor: '#0d6efd',
                    pointHoverRadius: 6,
                    spanGaps: false,
                    borderWidth: 2,
                    yAxisID: 'y',
                };

                new Chart(ctxT, {
                    type: 'line',
                    data: { labels: labels24, datasets: [datasetTemp] },
                    options: {
                        animation: false,
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'nearest', intersect: false },
                        elements: { point: { radius: 0, hoverRadius: 6 }, line: { borderCapStyle: 'round' } },
                        plugins: {
                            legend: { display: false },
                            tooltip: { backgroundColor: '#ffffff', titleColor: '#111827', bodyColor: '#111827', borderColor: '#e9ecef', borderWidth: 1, padding: 8, callbacks: { title(items){ return items[0].label; }, label(context){ const val = context.raw; return (val === null || val === undefined) ? 'Sin datos' : `Temperatura: ${val} °C`; } } },
                            layout: { padding: { top: 6 } }
                        },
                        scales: {
                            x: { ticks: { autoSkip: true, maxTicksLimit: 12, maxRotation: 0, font: { size: 11 }, color: '#6b7280', callback(value, index){ return this.chart && this.chart.data && this.chart.data.labels ? this.chart.data.labels[index] : value; } }, grid: { display: false } },
                            y: { beginAtZero: false, suggestedMin: (minTemp !== null ? Math.floor(minTemp - 2) : undefined), suggestedMax: (maxTemp !== null ? Math.ceil(maxTemp + 2) : undefined), grid: { color: 'rgba(15,23,42,0.04)' }, position: 'left', ticks: { color: '#6b7280', font: { size: 11 } } }
                        }
                    }
                });

                // HUMEDAD: gráfico separado
                const ctxH = canvasHum.getContext('2d');
                const heightH = canvasHum.height || canvasHum.clientHeight || 140;
                const gradientH = ctxH.createLinearGradient(0, 0, 0, heightH);
                gradientH.addColorStop(0, 'rgba(32,201,151,0.18)');
                gradientH.addColorStop(0.6, 'rgba(32,201,151,0.08)');
                gradientH.addColorStop(1, 'rgba(32,201,151,0.02)');

                const datasetHumOnly = {
                    label: 'Humedad promedio por hora (%)',
                    data: hourlyHum,
                    borderColor: '#20c997',
                    backgroundColor: gradientH,
                    tension: 0.25,
                    fill: true,
                    pointRadius: 0,
                    pointBackgroundColor: '#20c997',
                    pointBorderColor: '#fff',
                    pointHoverRadius: 5,
                    spanGaps: false,
                    borderWidth: 2,
                    yAxisID: 'y1',
                };

                new Chart(ctxH, {
                    type: 'line',
                    data: { labels: labels24, datasets: [datasetHumOnly] },
                    options: {
                        animation: false,
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'nearest', intersect: false },
                        elements: { point: { radius: 0, hoverRadius: 5 }, line: { borderCapStyle: 'round' } },
                        plugins: { legend: { display: false }, tooltip: { backgroundColor: '#ffffff', titleColor: '#111827', bodyColor: '#111827', borderColor: '#e9ecef', borderWidth: 1, padding: 8, callbacks: { title(items){ return items[0].label; }, label(context){ const val = context.raw; return (val === null || val === undefined) ? 'Sin datos' : `Humedad: ${val} %`; } } }, layout: { padding: { top: 6 } } },
                        scales: {
                            x: { ticks: { autoSkip: true, maxTicksLimit: 12, maxRotation: 0, font: { size: 11 }, color: '#6b7280', callback(value, index){ return this.chart && this.chart.data && this.chart.data.labels ? this.chart.data.labels[index] : value; } }, grid: { display: false } },
                            y1: { beginAtZero: true, suggestedMin: (minHum !== null ? Math.max(0, Math.floor(minHum - 5)) : undefined), suggestedMax: (maxHum !== null ? Math.min(100, Math.ceil(maxHum + 5)) : undefined), grid: { display: false }, position: 'left', ticks: { callback(v){ return v + ' %'; }, color: '#6b7280', font: { size: 11 } } }
                        }
                    }
                });
            });
        </script>

        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
            <style>
                body {
                    background-color: #faf8c7; /* fallback amarillo claro */
                    background-image: url("{% static 'img/background.jpg' %}");
                    background-repeat: no-repeat;
                    background-position: center center;
                    background-size: cover;
                    /* evitar repaints costosos en algunos navegadores */
                    background-attachment: scroll;
                }

                .chart-container{ padding: .6rem; border-radius: .5rem; background: rgba(255,255,255,0.72); }
                /* clases para controlar altura sin usar estilos inline en canvas */
                /* alturas ajustadas para apariencia tipo foto */
                /* alturas responsivas para que se ajusten dentro de la columna del sensor */
                /* equal heights for both charts */
                .chart-temp-canvas, .chart-hum-canvas { height: 200px !important; display:block; }
                @media (min-width: 768px) {
                    .chart-temp-canvas, .chart-hum-canvas { height: 240px !important; }
                }
                @media (min-width: 1200px) {
                    .chart-temp-canvas, .chart-hum-canvas { height: 260px !important; }
                }
                .chart-container{ padding: .4rem; border-radius: .5rem; background: rgba(255,255,255,0.85); }
                /* asegurar que ambos charts llenen la columna y tengan la misma altura */
                .chart-row .row > [class*="col-"] { display:flex; flex-direction:column; }
                .chart-row canvas { width:100% !important; height:100% !important; display:block; }
                .chart-row .chart-temp-canvas, .chart-row .chart-hum-canvas { min-height: 180px; }
                /* leyenda combinada centrada */
                .combined-legend{ font-size:13px; color:#374151; }
                .legend-dot{ width:12px; height:12px; display:inline-block; border-radius:50%; margin-right:6px; vertical-align:middle; box-shadow:0 0 0 3px rgba(0,0,0,0.03) inset; }
                .legend-item{ display:inline-flex; align-items:center; gap:6px; padding:4px 8px; background: rgba(255,255,255,0.0); border-radius:6px; }
            </style>
    </body>
</html>